from fastapi import APIRouter, HTTPException, BackgroundTasks
from pydantic import BaseModel
from typing import Dict, Any, List, Optional
import logging
from datetime import datetime

from ..backtesting.cerebro_base import CerebroBase
from ..strategies.three_step_strategy import ThreeStepStrategy
from ..models.strategy_models import Strategy, BacktestResult, StrategyOptimization

logger = logging.getLogger(__name__)
router = APIRouter()

# Pydantic models for API
class BacktestRequest(BaseModel):
    symbol: str
    start_date: str
    end_date: str
    initial_cash: float = 10000.0
    commission: float = 0.001
    strategy_params: Optional[Dict[str, Any]] = None

class StrategyCreateRequest(BaseModel):
    name: str
    description: Optional[str] = None
    strategy_class: str
    parameters: Optional[Dict[str, Any]] = None

class OptimizationRequest(BaseModel):
    strategy_id: int
    symbol: str
    start_date: str
    end_date: str
    parameter_ranges: Dict[str, List[float]]
    optimization_type: str = "parameter"

class LiveStrategyRequest(BaseModel):
    strategy_id: int
    symbol: str
    is_running: bool = True

@router.post("/backtest")
async def run_backtest(request: BacktestRequest):
    """Run backtest for a strategy"""
    try:
        # Create Cerebro instance
        cerebro = CerebroBase()
        
        # Set data
        success = cerebro.set_data_from_yahoo(
            symbols=request.symbol,
            period="1y",  # Will be filtered by dates
            since=request.start_date
        )
        
        if not success:
            raise HTTPException(status_code=400, detail="Failed to fetch data")
        
        # Set strategy
        strategy_params = request.strategy_params or {}
        cerebro.set_strategy(ThreeStepStrategy, **strategy_params)
        
        # Run backtest
        results = cerebro.run_backtest()
        
        # Add request info to results
        results.update({
            'symbol': request.symbol,
            'start_date': request.start_date,
            'end_date': request.end_date,
            'initial_cash': request.initial_cash,
            'commission': request.commission,
            'strategy_params': strategy_params
        })
        
        logger.info(f"Backtest completed for {request.symbol}")
        return results
        
    except Exception as e:
        logger.error(f"Error running backtest: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/backtest/{symbol}")
async def get_backtest_results(symbol: str, limit: int = 10):
    """Get recent backtest results for a symbol"""
    try:
        # This would query the database for backtest results
        # For now, return a placeholder
        return {
            "symbol": symbol,
            "results": [],
            "message": "Backtest results will be stored in database"
        }
        
    except Exception as e:
        logger.error(f"Error getting backtest results: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/strategies")
async def create_strategy(request: StrategyCreateRequest):
    """Create a new strategy"""
    try:
        # This would save to database
        strategy = {
            "id": 1,  # Would be generated by database
            "name": request.name,
            "description": request.description,
            "strategy_class": request.strategy_class,
            "parameters": request.parameters,
            "is_active": True,
            "created_at": datetime.utcnow().isoformat()
        }
        
        logger.info(f"Strategy created: {request.name}")
        return strategy
        
    except Exception as e:
        logger.error(f"Error creating strategy: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/strategies")
async def get_strategies():
    """Get all strategies"""
    try:
        # This would query the database
        strategies = [
            {
                "id": 1,
                "name": "Three Step Strategy",
                "description": "Multi-timeframe trading strategy",
                "strategy_class": "ThreeStepStrategy",
                "parameters": {
                    "trend_period": 20,
                    "entry_period": 10,
                    "atr_period": 14,
                    "risk_ratio": 3
                },
                "is_active": True
            }
        ]
        
        return {"strategies": strategies}
        
    except Exception as e:
        logger.error(f"Error getting strategies: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/strategies/{strategy_id}")
async def get_strategy(strategy_id: int):
    """Get a specific strategy"""
    try:
        # This would query the database
        strategy = {
            "id": strategy_id,
            "name": "Three Step Strategy",
            "description": "Multi-timeframe trading strategy",
            "strategy_class": "ThreeStepStrategy",
            "parameters": {
                "trend_period": 20,
                "entry_period": 10,
                "atr_period": 14,
                "risk_ratio": 3
            },
            "is_active": True
        }
        
        return strategy
        
    except Exception as e:
        logger.error(f"Error getting strategy: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/optimize")
async def optimize_strategy(request: OptimizationRequest, background_tasks: BackgroundTasks):
    """Optimize strategy parameters"""
    try:
        # This would run optimization in background
        optimization_id = 1  # Would be generated by database
        
        # Add optimization task to background
        background_tasks.add_task(
            run_optimization,
            optimization_id,
            request.dict()
        )
        
        return {
            "optimization_id": optimization_id,
            "status": "started",
            "message": "Optimization started in background"
        }
        
    except Exception as e:
        logger.error(f"Error starting optimization: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/optimize/{optimization_id}")
async def get_optimization_status(optimization_id: int):
    """Get optimization status"""
    try:
        # This would query the database for optimization status
        return {
            "optimization_id": optimization_id,
            "status": "completed",
            "progress": 100,
            "best_parameters": {
                "trend_period": 25,
                "entry_period": 12,
                "atr_period": 16,
                "risk_ratio": 2.5
            },
            "best_performance": {
                "total_return": 0.15,
                "sharpe_ratio": 1.8,
                "max_drawdown": 0.05
            }
        }
        
    except Exception as e:
        logger.error(f"Error getting optimization status: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/live/start")
async def start_live_strategy(request: LiveStrategyRequest):
    """Start live strategy execution"""
    try:
        # This would start live trading
        live_strategy = {
            "id": 1,
            "strategy_id": request.strategy_id,
            "symbol": request.symbol,
            "is_running": request.is_running,
            "start_time": datetime.utcnow().isoformat(),
            "status": "running"
        }
        
        logger.info(f"Live strategy started for {request.symbol}")
        return live_strategy
        
    except Exception as e:
        logger.error(f"Error starting live strategy: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/live/stop/{strategy_id}")
async def stop_live_strategy(strategy_id: int):
    """Stop live strategy execution"""
    try:
        # This would stop live trading
        return {
            "strategy_id": strategy_id,
            "status": "stopped",
            "stop_time": datetime.utcnow().isoformat()
        }
        
    except Exception as e:
        logger.error(f"Error stopping live strategy: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/live/status")
async def get_live_strategies_status():
    """Get status of all live strategies"""
    try:
        # This would query the database for live strategies
        live_strategies = [
            {
                "id": 1,
                "strategy_id": 1,
                "symbol": "AAPL",
                "is_running": True,
                "start_time": "2024-01-01T00:00:00",
                "current_position": {"size": 100, "avg_price": 150.0},
                "performance_metrics": {
                    "unrealized_pnl": 50.0,
                    "realized_pnl": 200.0
                }
            }
        ]
        
        return {"live_strategies": live_strategies}
        
    except Exception as e:
        logger.error(f"Error getting live strategies status: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/indicators/{symbol}")
async def get_technical_indicators(symbol: str, period: str = "1y"):
    """Get technical indicators for a symbol"""
    try:
        # Create Cerebro instance
        cerebro = CerebroBase()
        
        # Set data
        success = cerebro.set_data_from_yahoo(symbols=symbol, period=period)
        
        if not success:
            raise HTTPException(status_code=400, detail="Failed to fetch data")
        
        # Get indicators from data
        indicators = {
            "symbol": symbol,
            "period": period,
            "indicators": {
                "sma_20": "Available",
                "bollinger_bands": "Available", 
                "rsi": "Available",
                "atr": "Available"
            }
        }
        
        return indicators
        
    except Exception as e:
        logger.error(f"Error getting indicators: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# Background task functions
async def run_optimization(optimization_id: int, request_data: Dict[str, Any]):
    """Run strategy optimization in background"""
    try:
        logger.info(f"Starting optimization {optimization_id}")
        
        # This would implement actual optimization logic
        # Using Ray for distributed optimization
        import ray
        
        # Placeholder for optimization logic
        await asyncio.sleep(10)  # Simulate optimization time
        
        logger.info(f"Optimization {optimization_id} completed")
        
    except Exception as e:
        logger.error(f"Error in optimization {optimization_id}: {e}")
